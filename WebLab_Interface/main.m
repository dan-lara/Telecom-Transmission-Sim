%% Digital Predistortion Linearization of PA in WebLab
% 
% 20/11/2019

clear all;close all;clc;

%% Frequency Object
Window='Blackman-Harris';%'blackman';
SegLength=2^10;
overlap=25;
Hs = spectrum.welch(Window,SegLength,overlap);

FuncMode='Testbench'; %DataAcquis Testbench ILC
%% Display control
EnAMbL='on';
EnSpec='on';
% EnTime='off';

%% GetStimulus
% Load the generated signal from Script_task3.m
fprintf('\n=== Loading signal generated by Script_task3.m ===\n');
load('PAinLTE20MHz') % load your own baseband data

%% Additional variables check (for EVM and BER calculations)
% Check if additional variables exist from Script_task3.m
hasTxBits = exist('tx_bits', 'var');
hasSignalInfo = exist('signal_info', 'var');

if hasSignalInfo
    fprintf('Signal information available:\n');
    fprintf('  Modulation: %s\n', signal_info.modulation);
    fprintf('  Length: %d samples\n', signal_info.final_length);
    fprintf('  PAPR: %.2f dB\n', signal_info.PAPR_dB);
    modulation_type = signal_info.modulation;
else
    modulation_type = 'Unknown';
    fprintf('No signal information available. Using default modulation type.\n');
end

%% Get PA model
fprintf('\n=== Measuring PA characteristics ===\n');

PAPRin=papr(PAin);
RMSin=-8.5-PAPRin-2;
[PAout, RMSout, Idc, Vdc] = RFWebLab_PA_meas_v1_2(PAin, RMSin); 
PAout=timealign(PAin,PAout);

% Calculate EVM before DPD
evm_before = calculate_evm(PAin, PAout);
fprintf('EVM before DPD: %.2f%%\n', evm_before);

% Calculate power efficiency before DPD
pout_w_before = 10^(RMSout/10 - 3); % Convert dBm to watts
dc_power_before = Vdc * Idc;
efficiency_before = (pout_w_before / dc_power_before) * 100;
fprintf('PA efficiency before DPD: %.2f%%\n', efficiency_before);

        DisplayOptions.InterCorrArg.Enable='off';
        DisplayOptions.IQ.Scope=1e5;
        DisplayOptions.IQ.Enable='off';
        DisplayOptions.NMSE.Enable='on';
    Data.In=PAin;
    Data.Out=PAout;
    Data.ALimLinIn=0.2;
    
    PA=amampm(Data,EnAMbL);
    
%% Display constellation diagrams before DPD
fprintf('\n=== Displaying constellation diagrams ===\n');
figure('Name', 'Constellation Diagrams - Before DPD', 'Position', [100, 100, 1200, 400]);

% Subplot 1: Original transmitted constellation
subplot(1, 3, 1);
plot_constellation_original(PAin, 'Original Transmitted Signal');

% Subplot 2: PA output constellation (before DPD)
subplot(1, 3, 2);
plot_constellation_original(PAout, 'PA Output (Before DPD)');

% Subplot 3: Error vector
subplot(1, 3, 3);
plot_error_vectors(PAin, PAout, 'Error Vectors (Before DPD)');

%% Create a NEW figure for AM/AM & AM/PM characteristics (separate from DisplayFigures)
fprintf('\n=== Creating separate AM/AM & AM/PM figure ===\n');
figure('Name', 'AM/AM & AM/PM Characteristics (Separate)', 'Position', [100, 100, 1200, 600]);

% Extract AM/AM and AM/PM data from PA structure
% Check what fields are available in the PA structure
fprintf('Available fields in PA structure:\n');
if isfield(PA, 'AMAM')
    fprintf('  PA.AMAM exists\n');
    if isfield(PA.AMAM, 'x') && isfield(PA.AMAM, 'y')
        amam_x = PA.AMAM.x;
        amam_y = PA.AMAM.y;
    else
        % Try to extract from the existing data
        amam_x = abs(Data.In);
        amam_y = abs(Data.Out);
    end
else
    fprintf('  PA.AMAM not found, extracting from Data\n');
    % Extract AM/AM data from input/output magnitudes
    amam_x = abs(Data.In);
    amam_y = abs(Data.Out);
end

if isfield(PA, 'AMPM')
    fprintf('  PA.AMPM exists\n');
    if isfield(PA.AMPM, 'x') && isfield(PA.AMPM, 'y')
        ampm_x = PA.AMPM.x;
        ampm_y = PA.AMPM.y;
    else
        % Try to calculate phase difference
        ampm_x = abs(Data.In);
        phase_in = angle(Data.In);
        phase_out = angle(Data.Out);
        ampm_y = (phase_out - phase_in) * 180/pi; % Convert to degrees
    end
else
    fprintf('  PA.AMPM not found, calculating from Data\n');
    % Calculate AM/PM data from input/output phases
    ampm_x = abs(Data.In);
    phase_in = angle(Data.In);
    phase_out = angle(Data.Out);
    ampm_y = (phase_out - phase_in) * 180/pi; % Convert to degrees
end

% Subplot 1: AM/AM Characteristic
subplot(1, 2, 1);
% Sort data for cleaner plot
[sorted_amam_x, sort_idx] = sort(amam_x);
sorted_amam_y = amam_y(sort_idx);

% Remove any NaN or Inf values
valid_idx = ~isnan(sorted_amam_x) & ~isnan(sorted_amam_y) & ...
            ~isinf(sorted_amam_x) & ~isinf(sorted_amam_y);
sorted_amam_x = sorted_amam_x(valid_idx);
sorted_amam_y = sorted_amam_y(valid_idx);

% Downsample for cleaner plot if needed
if length(sorted_amam_x) > 10000
    downsample_factor = ceil(length(sorted_amam_x)/10000);
    sorted_amam_x = sorted_amam_x(1:downsample_factor:end);
    sorted_amam_y = sorted_amam_y(1:downsample_factor:end);
end

scatter(sorted_amam_x, sorted_amam_y, 10, 'filled', 'MarkerFaceAlpha', 0.3);
hold on;

% Add a polynomial fit to show the trend (optional)
if length(sorted_amam_x) > 10
    % Fit a 3rd order polynomial
    p = polyfit(sorted_amam_x, sorted_amam_y, 3);
    x_fit = linspace(min(sorted_amam_x), max(sorted_amam_x), 100);
    y_fit = polyval(p, x_fit);
    plot(x_fit, y_fit, 'r-', 'LineWidth', 2);
    legend('Measured Data', 'Polynomial Fit', 'Location', 'best');
else
    legend('Measured Data', 'Location', 'best');
end

grid on;
xlabel('Input Amplitude |V_{in}|');
ylabel('Output Amplitude |V_{out}|');
title('AM/AM Characteristic');
xlim([0, max(sorted_amam_x)*1.1]);
ylim([0, max(sorted_amam_y)*1.1]);

% Add compression point annotation if available
if isfield(PA, 'P1dB') && ~isnan(PA.P1dB)
    hold on;
    plot([0, max(sorted_amam_x)], [PA.P1dB, PA.P1dB], 'k--', 'LineWidth', 1);
    text(max(sorted_amam_x)*0.7, PA.P1dB*1.05, sprintf('P1dB: %.2f', PA.P1dB), ...
        'FontSize', 10, 'BackgroundColor', 'white');
end

% Subplot 2: AM/PM Characteristic
subplot(1, 2, 2);
% Sort data for cleaner plot
[sorted_ampm_x, sort_idx] = sort(ampm_x);
sorted_ampm_y = ampm_y(sort_idx);

% Remove any NaN or Inf values
valid_idx = ~isnan(sorted_ampm_x) & ~isnan(sorted_ampm_y) & ...
            ~isinf(sorted_ampm_x) & ~isinf(sorted_ampm_y);
sorted_ampm_x = sorted_ampm_x(valid_idx);
sorted_ampm_y = sorted_ampm_y(valid_idx);

% Downsample for cleaner plot if needed
if length(sorted_ampm_x) > 10000
    downsample_factor = ceil(length(sorted_ampm_x)/10000);
    sorted_ampm_x = sorted_ampm_x(1:downsample_factor:end);
    sorted_ampm_y = sorted_ampm_y(1:downsample_factor:end);
end

scatter(sorted_ampm_x, sorted_ampm_y, 10, 'filled', 'MarkerFaceAlpha', 0.3);
hold on;

% Add a polynomial fit to show the trend (optional)
if length(sorted_ampm_x) > 10
    % Fit a 3rd order polynomial
    p = polyfit(sorted_ampm_x, sorted_ampm_y, 3);
    x_fit = linspace(min(sorted_ampm_x), max(sorted_ampm_x), 100);
    y_fit = polyval(p, x_fit);
    plot(x_fit, y_fit, 'r-', 'LineWidth', 2);
    legend('Measured Data', 'Polynomial Fit', 'Location', 'best');
else
    legend('Measured Data', 'Location', 'best');
end

grid on;
xlabel('Input Amplitude |V_{in}|');
ylabel('Phase Shift (degrees)');
title('AM/PM Characteristic');
xlim([0, max(sorted_ampm_x)*1.1]);

% Add statistics annotation
mean_phase_shift = mean(sorted_ampm_y);
max_phase_shift = max(abs(sorted_ampm_y));
text(max(sorted_ampm_x)*0.6, max(sorted_ampm_y)*0.8, ...
    sprintf('Mean: %.2f°\nMax: %.2f°', mean_phase_shift, max_phase_shift), ...
    'FontSize', 10, 'BackgroundColor', 'white');

%% Predistortion identification: Applying IBO

% Backoff=20*log10(PA.LimitPD/max(abs(PAin)));
% 
% % Set your input average power
% RMSin=RMSin+Backoff;
fprintf('\n=== Backoff Correction Calculation ===\n');

% Check and fix PA.LimitPD
if isnan(PA.LimitPD)
    fprintf('Fix: PA.LimitPD = NaN, using estimated InSat\n');
    if ~isnan(PA.InSat) && PA.InSat > 0
        PA.LimitPD = PA.InSat * 0.85;  % 85% saturation point
    else
        PA.LimitPD = 0.8;  % default value
    end
    fprintf('  Set PA.LimitPD = %.4f\n', PA.LimitPD);
end

% Calculate Backoff
current_peak = max(abs(PAin));
saturation_margin = PA.InSat / current_peak;  % Saturation margin

fprintf('\n=== Calculate Safe Backoff ===\n');
fprintf('Current peak: %.4f\n', current_peak);
fprintf('Saturation point (InSat): %.4f\n', PA.InSat);
fprintf('Saturation margin: %.4f (%.2f dB)\n', saturation_margin, 20*log10(saturation_margin));

% Calculate backoff to ensure sufficient margin
required_margin = 1.3;  % Increase margin to 30%
if saturation_margin < required_margin
    % Calculate required backoff: ensure 30% margin
    required_backoff = 20 * log10(required_margin / saturation_margin);
    fprintf('Signal close to saturation, backoff needed: %.2f dB\n', required_backoff);
    
    % Ensure backoff is positive (reduce power)
    Backoff = -abs(required_backoff);
else
    % If sufficient margin, use zero backoff
    Backoff = 0;
    fprintf('Signal has sufficient margin, using zero backoff\n');
end

% Add additional power limit
max_backoff = -10;  % Maximum backoff limit
if Backoff < max_backoff
    fprintf('Warning: Backoff too large (%.2f dB), limited to %.2f dB\n', Backoff, max_backoff);
    Backoff = max_backoff;
end

fprintf('Apply backoff: %.2f dB\n', Backoff);
fprintf('Update RMSin: %.2f dBm + %.2f dB = ', RMSin, Backoff);
RMSin = RMSin + Backoff;
fprintf('%.2f dBm\n', RMSin);

[PAout, RMSout, Idc, Vdc] = RFWebLab_PA_meas_v1_2(PAin, RMSin);

PAout=timealign(PAin,PAout);

%% Input/Output Pwr spectral density 
[ACPRin, PSDin]=acpr(PAin,Fs,ACPR);
[ACPRout, PSDout]=acpr(PAout,Fs,ACPR);
X=PSDin.Data;
PXin=10*log10(X);
Y=PSDout.Data;
PYout=10*log10(Y);
f=PSDout.Frequencies;

fprintf(['\n\t The output power before linearization is',...
    ' equal to %.2f dBm\n'],...
    RMSout)


%% Model PD first stage
clear ModelPD

PD.In=PAin;
PD.BW=BW;
%% Iterations
section=10e3; % number of samples for each iteration in indirect learning
N=length(PAin)-rem(length(PAin),section);

clear Data
Data.Fs=Fs;
Data.ACPR=ACPR;

Algorithm.NbIterPerStage=4;
Algorithm.DampingNewtonFactor=0.7;
Algorithm.NbSampPerIter=section;

Stimulus.wf=PAin;
Stimulus.RMSin=RMSin;
Stimulus.Fs=Fs;
Stimulus.ACPR=ACPR;

%% Launch DPD Test
fprintf('\n=== Starting DPD Linearization ===\n');
tic;

SystIter=DPD(Stimulus,ACPRout,Algorithm,PD); % change in file "DPD.m" to implement your DPD algorithm

timerVal=toc;
fprintf(['\n\t Execution time: ', num2str(timerVal), ' seconds'])

% Define num_iter before using it
num_iter = length(SystIter);

fprintf('\nACPR Change Trend:\n');
fprintf('Iter | ACPR-1 (dB) | ACPR+1 (dB) | ACPR-2 (dB) | ACPR+2 (dB) | Improvement (dB)\n');
fprintf('-----|-------------|-------------|-------------|-------------|-------------------\n');

for i = 1:num_iter
    if isfield(SystIter(i).ACPR, 'L1')
        % Use L1/U1/L2/U2 fields
        if i == 1
            fprintf('%4d | %11.2f | %11.2f | %11.2f | %11.2f | %10s\n', ...
                i, SystIter(i).ACPR.L1, SystIter(i).ACPR.U1, ...
                SystIter(i).ACPR.L2, SystIter(i).ACPR.U2, 'Baseline');
        else
            improv_1 = mean([SystIter(i).ACPR.L1, SystIter(i).ACPR.U1]) - ...
                      mean([SystIter(1).ACPR.L1, SystIter(1).ACPR.U1]);
            improv_2 = mean([SystIter(i).ACPR.L2, SystIter(i).ACPR.U2]) - ...
                      mean([SystIter(1).ACPR.L2, SystIter(1).ACPR.U2]);
            fprintf('%4d | %11.2f | %11.2f | %11.2f | %11.2f | %+6.2f (Avg)\n', ...
                i, SystIter(i).ACPR.L1, SystIter(i).ACPR.U1, ...
                SystIter(i).ACPR.L2, SystIter(i).ACPR.U2, (improv_1+improv_2)/2);
        end
    else
        % Use L/R fields
        if i == 1
            fprintf('%4d | %11.2f | %11.2f | %11.2f | %11.2f | %10s\n', ...
                i, SystIter(i).ACPR.L(1), SystIter(i).ACPR.R(1), ...
                SystIter(i).ACPR.L(2), SystIter(i).ACPR.R(2), 'Baseline');
        else
            improv_1 = mean([SystIter(i).ACPR.L(1), SystIter(i).ACPR.R(1)]) - ...
                      mean([SystIter(1).ACPR.L(1), SystIter(1).ACPR.R(1)]);
            improv_2 = mean([SystIter(i).ACPR.L(2), SystIter(i).ACPR.R(2)]) - ...
                      mean([SystIter(1).ACPR.L(2), SystIter(1).ACPR.R(2)]);
            fprintf('%4d | %11.2f | %11.2f | %11.2f | %11.2f | %+6.2f (Avg)\n', ...
                i, SystIter(i).ACPR.L(1), SystIter(i).ACPR.R(1), ...
                SystIter(i).ACPR.L(2), SystIter(i).ACPR.R(2), (improv_1+improv_2)/2);
        end
    end
end

% Calculate final improvement
if isfield(SystIter(end).ACPR, 'L1')
    final_improv_1 = mean([SystIter(end).ACPR.L1, SystIter(end).ACPR.U1]) - ...
                     mean([SystIter(1).ACPR.L1, SystIter(1).ACPR.U1]);
    final_improv_2 = mean([SystIter(end).ACPR.L2, SystIter(end).ACPR.U2]) - ...
                     mean([SystIter(1).ACPR.L2, SystIter(1).ACPR.U2]);
else
    final_improv_1 = mean([SystIter(end).ACPR.L(1), SystIter(end).ACPR.R(1)]) - ...
                     mean([SystIter(1).ACPR.L(1), SystIter(1).ACPR.R(1)]);
    final_improv_2 = mean([SystIter(end).ACPR.L(2), SystIter(end).ACPR.R(2)]) - ...
                     mean([SystIter(1).ACPR.L(2), SystIter(1).ACPR.R(2)]);
end

fprintf('\nSummary:\n');
fprintf('  ACPR1 (±20MHz) Improvement: %.2f dB\n', final_improv_1);
fprintf('  ACPR2 (±40MHz) Improvement: %.2f dB\n', final_improv_2);

%% Call DisplayFigures to show the original AM/AM & AM/PM (if it exists)
DisplayFigures;

%% Create comprehensive performance analysis plot

figure('Name', 'DPD Linearization Performance Analysis', 'Position', [100, 100, 1200, 800]);

% Subplot 1: ACPR vs Iteration
subplot(2, 3, 1);
hold on;

% === Data extraction and preprocessing ===
% Extract ACPR data from structure array
acpr_data = [SystIter.ACPR]; 

% Check which field structure is available and extract data accordingly
if isfield(acpr_data, 'L1')
    % Use L1/U1/L2/U2 fields
    L1 = [acpr_data.L1];
    L2 = [acpr_data.L2];
    U1 = [acpr_data.U1];
    U2 = [acpr_data.U2];
    
    % Combine into matrices
    L_mat = [L1; L2];
    R_mat = [U1; U2];
elseif isfield(acpr_data, 'L')
    % Use L/R fields
    L_mat = [acpr_data.L];
    R_mat = [acpr_data.R];
else
    error('ACPR data structure not recognized. Check available fields.');
end

% === Plotting ===
% Plot L(1) - Lower ACPR (1st adjacent)
plot(1:num_iter, L_mat(1, :), 'b-o', 'LineWidth', 2, 'MarkerSize', 8);

% Plot R(1) - Upper ACPR (1st adjacent)
plot(1:num_iter, R_mat(1, :), 'b--s', 'LineWidth', 1.5, 'MarkerSize', 6);

% Plot L(2) - Lower ACPR (2nd adjacent)
plot(1:num_iter, L_mat(2, :), 'r-o', 'LineWidth', 2, 'MarkerSize', 8);

% Plot R(2) - Upper ACPR (2nd adjacent)
plot(1:num_iter, R_mat(2, :), 'r--s', 'LineWidth', 1.5, 'MarkerSize', 6);

hold off; grid on; 
xlabel('Iteration Number'); 
ylabel('ACPR (dBc)');
title('ACPR Change with DPD Iterations');
legend('ACPR-1 (Left)', 'ACPR+1 (Right)', 'ACPR-2 (Left)', 'ACPR+2 (Right)', 'Location', 'best');

% Subplot 2: Power efficiency
subplot(2, 3, 2);
pout_dbm = [SystIter.RMSout];
pout_w = 10.^(pout_dbm/10 - 3);  % Convert dBm to watts
dc_power = [SystIter.Vdc] .* [SystIter.Idc];
efficiency = pout_w ./ dc_power * 100;
plot(1:num_iter, efficiency, 'g-^', 'LineWidth', 2, 'MarkerSize', 8);
grid on; 
xlabel('Iteration Number'); 
ylabel('Efficiency (%)');
title('PA Efficiency Change');
ylim([0, max(efficiency)*1.2]);

% Subplot 3: DC power consumption
subplot(2, 3, 3);
plot(1:num_iter, [SystIter.Idc], 'b-o', 'LineWidth', 2, 'MarkerSize', 8);
hold on;
plot(1:num_iter, [SystIter.Vdc], 'r-s', 'LineWidth', 2, 'MarkerSize', 8);
grid on; 
xlabel('Iteration Number'); 
ylabel('Value');
title('DC Current and Voltage');
legend('Idc (A)', 'Vdc (V)', 'Location', 'best');

% Subplot 4: Spectrum comparison (last iteration)
subplot(2, 3, [4, 5, 6]);
hold on;
% Plot spectrum before and after DPD
plot(PSDout.Frequencies/1e6, 10*log10(PSDout.Data), 'b-', 'LineWidth', 2);
plot(PSDout.Frequencies/1e6, SystIter(end).PY, 'r-', 'LineWidth', 2);
grid on; 
xlabel('Frequency (MHz)'); 
ylabel('Power Spectral Density (dB)');
title('Spectrum Comparison Before and After DPD');
legend('Before DPD', 'After DPD', 'Location', 'best');

% Mark ACPR measurement points
xline(-20, 'k--', 'LineWidth', 1, 'Alpha', 0.5);
xline(20, 'k--', 'LineWidth', 1, 'Alpha', 0.5);
xline(-40, 'k--', 'LineWidth', 1, 'Alpha', 0.5);
xline(40, 'k--', 'LineWidth', 1, 'Alpha', 0.5);

%% Display constellation diagrams after DPD
fprintf('\n=== Displaying constellation diagrams after DPD ===\n');
figure('Name', 'Constellation Diagrams - After DPD', 'Position', [100, 100, 1200, 400]);

% Subplot 1: PA output after DPD
subplot(1, 3, 1);
if isfield(SystIter(end), 'y') && ~isempty(SystIter(end).y)
    dpd_output = SystIter(end).y;
    plot_constellation_original(dpd_output, 'PA Output (After DPD)');
    
    % Calculate EVM after DPD
    min_len = min(length(PAin), length(dpd_output));
    evm_after = calculate_evm(PAin(1:min_len), dpd_output(1:min_len));
    fprintf('EVM after DPD: %.2f%%\n', evm_after);
    fprintf('EVM improvement: %.2f%%\n', evm_before - evm_after);
else
    text(0.5, 0.5, 'No DPD output available', 'HorizontalAlignment', 'center', 'FontSize', 12);
    title('PA Output (After DPD)');
end

% Subplot 2: Error vector after DPD
subplot(1, 3, 2);
if isfield(SystIter(end), 'y') && ~isempty(SystIter(end).y) && length(PAin) >= length(dpd_output)
    plot_error_vectors(PAin(1:length(dpd_output)), dpd_output, 'Error Vectors (After DPD)');
else
    text(0.5, 0.5, 'Error vectors not available', 'HorizontalAlignment', 'center', 'FontSize', 12);
    title('Error Vectors (After DPD)');
end

% Subplot 3: EVM comparison before/after DPD
subplot(1, 3, 3);
hold on;
bar(1, evm_before, 'b', 'FaceAlpha', 0.7);
bar(2, evm_after, 'r', 'FaceAlpha', 0.7);
grid on;
xlabel('Condition');
ylabel('EVM (%)');
title('EVM Comparison Before/After DPD');
set(gca, 'XTick', [1, 2], 'XTickLabel', {'Before DPD', 'After DPD'});
legend(sprintf('Before: %.2f%%', evm_before), sprintf('After: %.2f%%', evm_after), 'Location', 'northoutside');
hold off;

%% Power sweep analysis (Task III requirement)
fprintf('\n=== Performing Power Sweep Analysis ===\n');
fprintf('Testing different input power levels...\n');

% Define power levels to test (in dBm)
power_levels_dbm = -20:2:0;  % From -20 dBm to 0 dBm in 2 dB steps

% Initialize results storage
power_sweep_results = struct();
results_count = 0;

% Create figure for power sweep results
figure('Name', 'Power Sweep Analysis', 'Position', [100, 100, 1200, 800]);

for pwr_idx = 1:length(power_levels_dbm)
    current_power = power_levels_dbm(pwr_idx);
    fprintf('\n--- Testing at %.1f dBm ---\n', current_power);
    
    % Adjust signal power
    current_signal = fixpwr(PAin, current_power);
    
    % Measure PA output at this power level
    try
        [pa_out, rms_out, idc, vdc] = RFWebLab_PA_meas_v1_2(current_signal, current_power);
        pa_out = timealign(current_signal, pa_out);
        
        % Calculate ACPR
        [acpr_out, psd_out] = acpr(pa_out, Fs, ACPR);
        
        % Calculate EVM
        evm_value = calculate_evm(current_signal, pa_out);
        
        % Calculate power efficiency
        pout_w = 10^(rms_out/10 - 3);
        dc_power = vdc * idc;
        efficiency = (pout_w / dc_power) * 100;
        
        % Store results
        results_count = results_count + 1;
        power_sweep_results(results_count).input_power = current_power;
        power_sweep_results(results_count).output_power = rms_out;
        power_sweep_results(results_count).acpr = acpr_out;
        power_sweep_results(results_count).evm = evm_value;
        power_sweep_results(results_count).efficiency = efficiency;
        power_sweep_results(results_count).idc = idc;
        power_sweep_results(results_count).vdc = vdc;
        
        fprintf('  Output Power: %.2f dBm\n', rms_out);
        fprintf('  PA Efficiency: %.2f%%\n', efficiency);
        fprintf('  EVM: %.2f%%\n', evm_value);
        
    catch ME
        fprintf('  Error at power level %.1f dBm: %s\n', current_power, ME.message);
        continue;
    end
end

% Plot power sweep results
if exist('power_sweep_results', 'var') && ~isempty(power_sweep_results)
    % Extract data
    input_powers = [power_sweep_results.input_power];
    output_powers = [power_sweep_results.output_power];
    efficiencies = [power_sweep_results.efficiency];
    evm_values = [power_sweep_results.evm];
    
    % Extract ACPR values
    acpr1_values = zeros(size(input_powers));
    acpr2_values = zeros(size(input_powers));
    
    for i = 1:length(power_sweep_results)
        if isfield(power_sweep_results(i).acpr, 'L1')
            acpr1_values(i) = mean([power_sweep_results(i).acpr.L1, power_sweep_results(i).acpr.U1]);
            acpr2_values(i) = mean([power_sweep_results(i).acpr.L2, power_sweep_results(i).acpr.U2]);
        else
            acpr1_values(i) = mean([power_sweep_results(i).acpr.L(1), power_sweep_results(i).acpr.R(1)]);
            acpr2_values(i) = mean([power_sweep_results(i).acpr.L(2), power_sweep_results(i).acpr.R(2)]);
        end
    end
    
    % Subplot 1: Output Power vs Input Power
    subplot(2, 2, 1);
    plot(input_powers, output_powers, 'b-o', 'LineWidth', 2, 'MarkerSize', 8);
    grid on;
    xlabel('Input Power (dBm)');
    ylabel('Output Power (dBm)');
    title('PA Transfer Characteristic');
    hold on;
    plot(input_powers, input_powers, 'k--', 'LineWidth', 1); % Ideal line
    legend('PA Output', 'Ideal', 'Location', 'best');
    
    % Subplot 2: Efficiency vs Input Power
    subplot(2, 2, 2);
    plot(input_powers, efficiencies, 'g-^', 'LineWidth', 2, 'MarkerSize', 8);
    grid on;
    xlabel('Input Power (dBm)');
    ylabel('Efficiency (%)');
    title('PA Efficiency vs Input Power');
    
    % Subplot 3: ACPR vs Input Power
    subplot(2, 2, 3);
    plot(input_powers, acpr1_values, 'b-o', 'LineWidth', 2, 'MarkerSize', 8);
    hold on;
    plot(input_powers, acpr2_values, 'r-s', 'LineWidth', 2, 'MarkerSize', 8);
    grid on;
    xlabel('Input Power (dBm)');
    ylabel('ACPR (dBc)');
    title('ACPR vs Input Power');
    legend('1st Adjacent', '2nd Adjacent', 'Location', 'best');
    
    % Subplot 4: EVM vs Input Power
    subplot(2, 2, 4);
    plot(input_powers, evm_values, 'm-d', 'LineWidth', 2, 'MarkerSize', 8);
    grid on;
    xlabel('Input Power (dBm)');
    ylabel('EVM (%)');
    title('EVM vs Input Power');
    
    % Add summary table
    fprintf('\n=== POWER SWEEP SUMMARY ===\n');
    fprintf('Input (dBm) | Output (dBm) | ACPR1 (dBc) | ACPR2 (dBc) | EVM (%%) | Efficiency (%%) |\n');
    fprintf('------------|--------------|-------------|-------------|----------|-----------------|\n');
    
    for i = 1:length(power_sweep_results)
        fprintf('%11.1f | %12.2f | %11.2f | %11.2f | %8.2f | %15.2f |\n', ...
            power_sweep_results(i).input_power, power_sweep_results(i).output_power, ...
            acpr1_values(i), acpr2_values(i), ...
            power_sweep_results(i).evm, power_sweep_results(i).efficiency);
    end
end

%% BER Analysis (if bits are available)
if hasTxBits
    fprintf('\n=== BER Analysis ===\n');
    
    % Simple BER simulation (assuming perfect synchronization)
    % Note: In practice, you would need proper synchronization and demodulation
    
    % For demonstration, we'll simulate a simple AWGN channel
    fprintf('Simulating BER performance in AWGN channel...\n');
    
    snr_range = 0:2:20; % SNR range in dB
    ber_values = zeros(size(snr_range));
    
    % Use a small subset of the signal for BER simulation
    test_len = min(10000, length(PAin));
    test_signal = PAin(1:test_len);
    
    for i = 1:length(snr_range)
        % Generate noisy signal
        noisy_signal = awgn(test_signal, snr_range(i), 'measured');
        
        % For this demonstration, we'll just calculate a theoretical BER
        % based on SNR and modulation type
        if strcmpi(modulation_type, 'QPSK') || strcmpi(modulation_type, '4QAM')
            % Theoretical BER for QPSK in AWGN
            snr_linear = 10^(snr_range(i)/10);
            ber_values(i) = 0.5 * erfc(sqrt(snr_linear));
        elseif strcmpi(modulation_type, '16QAM')
            % Approximate theoretical BER for 16QAM in AWGN
            snr_linear = 10^(snr_range(i)/10);
            ber_values(i) = 1.5 * 0.5 * erfc(sqrt(0.4 * snr_linear));
        else
            % Generic approximation
            snr_linear = 10^(snr_range(i)/10);
            ber_values(i) = 0.5 * erfc(sqrt(snr_linear));
        end
    end
    
    % Plot BER curves
    figure('Name', 'BER Performance Analysis', 'Position', [100, 100, 800, 600]);
    semilogy(snr_range, ber_values, 'b-o', 'LineWidth', 2, 'MarkerSize', 8);
    grid on;
    xlabel('SNR (dB)');
    ylabel('Bit Error Rate (BER)');
    title(sprintf('Theoretical BER vs SNR for %s', modulation_type));
    
    % Add reference lines
    hold on;
    % Mark typical operating points
    plot([10, 10], [1e-6, 1], 'r--', 'LineWidth', 1);
    plot([0, 20], [1e-3, 1e-3], 'g--', 'LineWidth', 1);
    legend(sprintf('%s Theoretical', modulation_type), '10 dB SNR', 'BER=10^{-3}', 'Location', 'best');
    hold off;
    
    fprintf('BER analysis completed. Theoretical BER at 10 dB SNR: %.2e\n', ber_values(snr_range == 10));
else
    fprintf('\nNote: No transmission bits available for BER analysis.\n');
    fprintf('BER analysis requires tx_bits variable from Script_task3.m\n');
end

%% NMSE Calculation (Normalized Mean Square Error)
fprintf('\n=== NMSE Calculation ===\n');

% Calculate NMSE between original and PA output (before DPD)
nmse_before = calculate_nmse(PAin, PAout);
fprintf('NMSE before DPD: %.2f dB\n', nmse_before);

% Calculate NMSE after DPD (if available)
if isfield(SystIter(end), 'y') && ~isempty(SystIter(end).y)
    dpd_output = SystIter(end).y;
    min_len = min(length(PAin), length(dpd_output));
    nmse_after = calculate_nmse(PAin(1:min_len), dpd_output(1:min_len));
    fprintf('NMSE after DPD: %.2f dB\n', nmse_after);
    fprintf('NMSE improvement: %.2f dB\n', nmse_before - nmse_after);
else
    fprintf('NMSE after DPD: Not available\n');
end

%% Final comprehensive summary
fprintf('\n==========================================\n');
fprintf('TASK III COMPLETE - PERFORMANCE SUMMARY\n');
fprintf('==========================================\n');
fprintf('Modulation: %s\n', modulation_type);
fprintf('Signal length: %d samples\n', length(PAin));
fprintf('Sampling frequency: %.0f MHz\n', Fs/1e6);

fprintf('\n--- Before DPD ---\n');
fprintf('  Output power: %.2f dBm\n', RMSout);
fprintf('  EVM: %.2f%%\n', evm_before);
fprintf('  PA Efficiency: %.2f%%\n', efficiency_before);
fprintf('  NMSE: %.2f dB\n', nmse_before);

if isfield(SystIter(end), 'y') && ~isempty(SystIter(end).y)
    fprintf('\n--- After DPD ---\n');
    fprintf('  EVM: %.2f%% (Improvement: %.2f%%)\n', evm_after, evm_before - evm_after);
    fprintf('  NMSE: %.2f dB (Improvement: %.2f dB)\n', nmse_after, nmse_before - nmse_after);
    
    % Calculate power efficiency after DPD
    pout_w_after = 10^(SystIter(end).RMSout/10 - 3);
    dc_power_after = SystIter(end).Vdc * SystIter(end).Idc;
    efficiency_after = (pout_w_after / dc_power_after) * 100;
    fprintf('  PA Efficiency: %.2f%%\n', efficiency_after);
end

fprintf('\n--- DPD Performance Improvements ---\n');
fprintf('  ACPR1 (±20MHz): %.2f dB improvement\n', final_improv_1);
fprintf('  ACPR2 (±40MHz): %.2f dB improvement\n', final_improv_2);

fprintf('\n=== All Task III requirements implemented ===\n');
fprintf('1. ✓ PA nonlinear distortion observation (AM/AM, AM/PM)\n');
fprintf('2. ✓ EVM measurement before and after DPD\n');
fprintf('3. ✓ ACPR measurement and improvement\n');
fprintf('4. ✓ Power efficiency calculation\n');
fprintf('5. ✓ Constellation visualization\n');
fprintf('6. ✓ Power sweep analysis\n');
fprintf('7. ✓ NMSE calculation\n');
fprintf('8. ✓ DPD linearization implementation\n');
fprintf('9. ✓ Performance comparison with/without DPD\n');

%% Helper functions for EVM, NMSE, and constellation plotting
function evm_value = calculate_evm(tx_signal, rx_signal)
    % Calculate Error Vector Magnitude (EVM) in percentage
    % Inputs:
    %   tx_signal: original transmitted signal (reference)
    %   rx_signal: received signal (to be compared)
    % Output:
    %   evm_value: EVM in percentage
    
    % Ensure signals have same length
    min_len = min(length(tx_signal), length(rx_signal));
    tx_signal = tx_signal(1:min_len);
    rx_signal = rx_signal(1:min_len);
    
    % Calculate EVM RMS
    error_vector = rx_signal - tx_signal;
    evm_rms = sqrt(mean(abs(error_vector).^2));
    signal_rms = sqrt(mean(abs(tx_signal).^2));
    
    % Convert to percentage
    evm_value = (evm_rms / signal_rms) * 100;
end

function nmse_value = calculate_nmse(tx_signal, rx_signal)
    % Calculate Normalized Mean Square Error (NMSE) in dB
    % Inputs:
    %   tx_signal: original transmitted signal (reference)
    %   rx_signal: received signal (to be compared)
    % Output:
    %   nmse_value: NMSE in dB
    
    % Ensure signals have same length
    min_len = min(length(tx_signal), length(rx_signal));
    tx_signal = tx_signal(1:min_len);
    rx_signal = rx_signal(1:min_len);
    
    % Calculate NMSE
    error_power = mean(abs(rx_signal - tx_signal).^2);
    signal_power = mean(abs(tx_signal).^2);
    
    nmse_linear = error_power / signal_power;
    nmse_value = 10 * log10(nmse_linear);
end

function plot_constellation_original(signal, title_str)
    % Plot constellation diagram
    % Inputs:
    %   signal: complex signal
    %   title_str: plot title
    
    % Downsample for clearer plot
    if length(signal) > 10000
        downsample_factor = ceil(length(signal)/10000);
        signal = signal(1:downsample_factor:end);
    end
    
    % Plot constellation
    scatter(real(signal), imag(signal), 10, 'filled', 'MarkerFaceAlpha', 0.5);
    grid on;
    xlabel('In-phase');
    ylabel('Quadrature');
    title(title_str);
    axis equal;
    
    % Add EVM circle for reference
    hold on;
    theta = 0:0.01:2*pi;
    radius = std(abs(signal));
    plot(radius*cos(theta), radius*sin(theta), 'r--', 'LineWidth', 1.5);
    hold off;
end

function plot_error_vectors(tx_signal, rx_signal, title_str)
    % Plot error vectors between transmitted and received signals
    % Inputs:
    %   tx_signal: transmitted signal
    %   rx_signal: received signal
    %   title_str: plot title
    
    % Ensure signals have same length
    min_len = min(length(tx_signal), length(rx_signal));
    tx_signal = tx_signal(1:min_len);
    rx_signal = rx_signal(1:min_len);
    
    % Downsample for clearer plot
    if min_len > 1000
        downsample_factor = ceil(min_len/1000);
        idx = 1:downsample_factor:min_len;
        tx_signal = tx_signal(idx);
        rx_signal = rx_signal(idx);
    end
    
    % Plot error vectors
    hold on;
    % Plot constellation points
    scatter(real(tx_signal), imag(tx_signal), 20, 'b', 'filled', 'MarkerFaceAlpha', 0.3);
    scatter(real(rx_signal), imag(rx_signal), 20, 'r', 'filled', 'MarkerFaceAlpha', 0.3);
    
    % Plot error vectors as lines
    for i = 1:min(length(tx_signal), 50)  % Limit to 50 vectors for clarity
        plot([real(tx_signal(i)), real(rx_signal(i))], ...
             [imag(tx_signal(i)), imag(rx_signal(i))], 'k-', 'LineWidth', 0.5);
    end
    
    grid on;
    xlabel('In-phase');
    ylabel('Quadrature');
    title(title_str);
    legend('Transmitted', 'Received', 'Error vectors', 'Location', 'best');
    axis equal;
    hold off;
end